import pytest
from src.models.recipe_tag import RecipeTag
from src.models.recipe import Recipe
from src.models.tag import Tag, TagCategory
from src.models.user import User
from sqlmodel import Session, create_engine, SQLModel
from sqlalchemy import text

def test_create_recipe_tag_instance():
    """Test creating a RecipeTag instance with all fields."""
    recipe_tag_data = {
        "recipe_id": 1,
        "tag_id": 2
    }
    recipe_tag = RecipeTag(**recipe_tag_data)

    assert recipe_tag.recipe_id == recipe_tag_data["recipe_id"]
    assert recipe_tag.tag_id == recipe_tag_data["tag_id"]
    assert recipe_tag.id is None  # Assuming id is generated by the DB or BaseModel

def test_recipe_tag_string_representation():
    """Test the string representation of the RecipeTag model."""
    recipe_tag_data = {
        "recipe_id": 1,
        "tag_id": 2
    }
    recipe_tag = RecipeTag(**recipe_tag_data)
    
    expected_repr = f"<RecipeTag recipe_id={recipe_tag.recipe_id} tag_id={recipe_tag.tag_id}>"
    assert str(recipe_tag) == f"<RecipeTag recipe_id={recipe_tag.recipe_id} tag_id={recipe_tag.tag_id}>"
    assert repr(recipe_tag) == expected_repr

def test_recipe_tag_comparison():
    """Test recipe tag comparison functionality."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag2 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag3 = RecipeTag(recipe_id=1, tag_id=3)
    recipe_tag4 = RecipeTag(recipe_id=2, tag_id=2)
    
    # Test equality
    assert recipe_tag1 == recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag1 != recipe_tag4
    
    # Test that different instances with same values are equal
    assert recipe_tag1 == recipe_tag2  # Should be equal despite being different instances

def test_recipe_tag_with_different_recipe_ids():
    """Test recipe tags with different recipe IDs."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=1)
    recipe_tag2 = RecipeTag(recipe_id=2, tag_id=1)
    recipe_tag3 = RecipeTag(recipe_id=3, tag_id=1)
    
    # All should be different
    assert recipe_tag1 != recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag2 != recipe_tag3
    
    # But they should have the same tag_id
    assert recipe_tag1.tag_id == recipe_tag2.tag_id == recipe_tag3.tag_id

def test_recipe_tag_with_different_tag_ids():
    """Test recipe tags with different tag IDs."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=1)
    recipe_tag2 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag3 = RecipeTag(recipe_id=1, tag_id=3)
    
    # All should be different
    assert recipe_tag1 != recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag2 != recipe_tag3
    
    # But they should have the same recipe_id
    assert recipe_tag1.recipe_id == recipe_tag2.recipe_id == recipe_tag3.recipe_id

def test_recipe_tag_edge_cases():
    """Test edge cases for recipe tag creation."""
    # Test with zero IDs (though these might not be valid in practice)
    recipe_tag = RecipeTag(recipe_id=0, tag_id=0)
    assert recipe_tag.recipe_id == 0
    assert recipe_tag.tag_id == 0
    
    # Test with large IDs
    recipe_tag = RecipeTag(recipe_id=999999, tag_id=999999)
    assert recipe_tag.recipe_id == 999999
    assert recipe_tag.tag_id == 999999

def test_recipe_tag_immutability():
    """Test that recipe tag fields are properly set and immutable."""
    recipe_tag = RecipeTag(recipe_id=1, tag_id=2)
    
    # Test initial values
    assert recipe_tag.recipe_id == 1
    assert recipe_tag.tag_id == 2
    
    # Test that we can't accidentally change the values
    # (This would be caught by Pydantic validation if we tried to reassign)

def test_recipe_tag_relationship_simulation():
    """Test that recipe tags properly represent many-to-many relationships."""
    # Simulate a recipe with multiple tags
    recipe_id = 1
    tag_ids = [1, 2, 3, 4, 5]
    
    recipe_tags = [RecipeTag(recipe_id=recipe_id, tag_id=tag_id) for tag_id in tag_ids]
    
    # All should have the same recipe_id
    for recipe_tag in recipe_tags:
        assert recipe_tag.recipe_id == recipe_id
    
    # All should have different tag_ids
    tag_id_set = {rt.tag_id for rt in recipe_tags}
    assert len(tag_id_set) == len(tag_ids)
    
    # All should be unique (check manually since RecipeTag is not hashable)
    for i, rt1 in enumerate(recipe_tags):
        for j, rt2 in enumerate(recipe_tags):
            if i != j:
                assert rt1 != rt2

def test_recipe_tag_composite_key_simulation():
    """Test that recipe tags behave like they have a composite primary key."""
    # Create multiple recipe tags with different combinations
    recipe_tags = [
        RecipeTag(recipe_id=1, tag_id=1),
        RecipeTag(recipe_id=1, tag_id=2),
        RecipeTag(recipe_id=2, tag_id=1),
        RecipeTag(recipe_id=2, tag_id=2),
    ]
    
    # All should be unique (check manually since RecipeTag is not hashable)
    for i, rt1 in enumerate(recipe_tags):
        for j, rt2 in enumerate(recipe_tags):
            if i != j:
                assert rt1 != rt2
    
    # Test that same combination is equal
    rt1 = RecipeTag(recipe_id=1, tag_id=1)
    rt2 = RecipeTag(recipe_id=1, tag_id=1)
    assert rt1 == rt2

def test_recipe_tag_validation():
    """Test that recipe tag validation works correctly."""
    # Test with valid integer IDs
    recipe_tag = RecipeTag(recipe_id=1, tag_id=2)
    assert recipe_tag.recipe_id == 1
    assert recipe_tag.tag_id == 2
    
    # Test with string IDs (should be converted to int if possible)
    # This depends on how SQLModel handles the conversion
    # For now, we'll test with integers as that's what the model expects

def test_recipe_tag_representation_consistency():
    """Test that string representations are consistent."""
    recipe_tag = RecipeTag(recipe_id=123, tag_id=456)
    
    # Test str representation
    str_repr = str(recipe_tag)
    assert "RecipeTag" in str_repr
    assert "123" in str_repr
    assert "456" in str_repr
    
    # Test repr representation
    repr_repr = repr(recipe_tag)
    assert "RecipeTag" in repr_repr
    assert "123" in repr_repr
    assert "456" in repr_repr
    
    # Both should be the same for this model
    assert str_repr == repr_repr

def test_recipe_tag_equality_consistency():
    """Test that recipe tag equality is consistent."""
    rt1 = RecipeTag(recipe_id=1, tag_id=2)
    rt2 = RecipeTag(recipe_id=1, tag_id=2)
    rt3 = RecipeTag(recipe_id=1, tag_id=3)
    
    # Equal objects should be equal
    assert rt1 == rt2
    assert rt2 == rt1  # Symmetric
    
    # Different objects should not be equal
    assert rt1 != rt3
    assert rt3 != rt1  # Symmetric
    
    # Reflexive
    assert rt1 == rt1
    assert rt2 == rt2
    assert rt3 == rt3

def test_recipe_tag_not_hashable():
    """Test that recipe tags are not hashable (as expected for mutable objects)."""
    rt1 = RecipeTag(recipe_id=1, tag_id=2)
    
    # RecipeTag should not be hashable
    with pytest.raises(TypeError, match="unhashable type"):
        hash(rt1)
    
    # Should not be usable in sets
    with pytest.raises(TypeError, match="unhashable type"):
        {rt1}
    
    # Should not be usable as dictionary keys
    with pytest.raises(TypeError, match="unhashable type"):
        {rt1: "value"}


# Database operation tests
@pytest.fixture
def test_db():
    """Create a test database engine."""
    # Use in-memory SQLite for testing
    engine = create_engine("sqlite:///:memory:", echo=False)
    SQLModel.metadata.create_all(engine)
    return engine

@pytest.fixture
def test_session(test_db):
    """Create a test database session."""
    with Session(test_db) as session:
        yield session

def test_recipe_tag_database_creation_with_auto_increment(test_session):
    """Test that RecipeTag can be created in database with auto-incrementing ID."""
    # Create a test user first
    user = User(
        email="test@example.com",
        full_name="Test User",
        hashed_password="hashed_password"
    )
    test_session.add(user)
    test_session.commit()
    test_session.refresh(user)
    
    # Create a test recipe
    recipe = Recipe(
        title="Test Recipe",
        description="A test recipe",
        ingredients=[{"name": "flour", "amount": "2 cups"}],
        instructions=["Mix ingredients"],
        preparation_time=10,
        cooking_time=20,
        servings=4,
        user_id=user.uuid
    )
    test_session.add(recipe)
    test_session.commit()
    test_session.refresh(recipe)
    
    # Create a test tag
    tag = Tag(
        name="test tag",
        category=TagCategory.MEAL_TYPES
    )
    test_session.add(tag)
    test_session.commit()
    test_session.refresh(tag)
    
    # Create a RecipeTag without providing an ID
    recipe_tag = RecipeTag(
        recipe_id=recipe.id,
        tag_id=tag.id
    )
    
    # Add to session and commit
    test_session.add(recipe_tag)
    test_session.commit()
    test_session.refresh(recipe_tag)
    
    # Verify that an ID was auto-generated
    assert recipe_tag.id is not None
    assert isinstance(recipe_tag.id, int)
    assert recipe_tag.id > 0
    
    # Verify other fields are correct
    assert recipe_tag.recipe_id == recipe.id
    assert recipe_tag.tag_id == tag.id
    assert recipe_tag.created_at is not None
    assert recipe_tag.updated_at is not None

def test_recipe_tag_database_multiple_creations(test_session):
    """Test that multiple RecipeTags can be created with sequential auto-incrementing IDs."""
    # Create test data
    user = User(
        email="test@example.com",
        full_name="Test User",
        hashed_password="hashed_password"
    )
    test_session.add(user)
    test_session.commit()
    test_session.refresh(user)
    
    recipe = Recipe(
        title="Test Recipe",
        description="A test recipe",
        ingredients=[{"name": "flour", "amount": "2 cups"}],
        instructions=["Mix ingredients"],
        preparation_time=10,
        cooking_time=20,
        servings=4,
        user_id=user.uuid
    )
    test_session.add(recipe)
    test_session.commit()
    test_session.refresh(recipe)
    
    tags = []
    for i in range(3):
        tag = Tag(
            name=f"test tag {i}",
            category=TagCategory.MEAL_TYPES
        )
        test_session.add(tag)
        test_session.commit()
        test_session.refresh(tag)
        tags.append(tag)
    
    # Create multiple RecipeTags
    recipe_tags = []
    for tag in tags:
        recipe_tag = RecipeTag(
            recipe_id=recipe.id,
            tag_id=tag.id
        )
        test_session.add(recipe_tag)
        recipe_tags.append(recipe_tag)
    
    test_session.commit()
    
    # Refresh all recipe tags to get their IDs
    for recipe_tag in recipe_tags:
        test_session.refresh(recipe_tag)
    
    # Verify that all have auto-generated IDs
    ids = [rt.id for rt in recipe_tags]
    assert all(id is not None for id in ids)
    assert all(isinstance(id, int) for id in ids)
    assert all(id > 0 for id in ids)
    
    # Verify that IDs are sequential (for SQLite in-memory)
    # Note: This might not be true for all databases, but it should be for SQLite
    sorted_ids = sorted(ids)
    assert sorted_ids == ids  # Should be in order if sequential

def test_recipe_tag_database_query(test_session):
    """Test that RecipeTags can be queried from the database."""
    # Create test data
    user = User(
        email="test@example.com",
        full_name="Test User",
        hashed_password="hashed_password"
    )
    test_session.add(user)
    test_session.commit()
    test_session.refresh(user)
    
    recipe = Recipe(
        title="Test Recipe",
        description="A test recipe",
        ingredients=[{"name": "flour", "amount": "2 cups"}],
        instructions=["Mix ingredients"],
        preparation_time=10,
        cooking_time=20,
        servings=4,
        user_id=user.uuid
    )
    test_session.add(recipe)
    test_session.commit()
    test_session.refresh(recipe)
    
    tag = Tag(
        name="test tag",
        category=TagCategory.MEAL_TYPES
    )
    test_session.add(tag)
    test_session.commit()
    test_session.refresh(tag)
    
    # Create and save a RecipeTag
    recipe_tag = RecipeTag(
        recipe_id=recipe.id,
        tag_id=tag.id
    )
    test_session.add(recipe_tag)
    test_session.commit()
    test_session.refresh(recipe_tag)
    
    # Query the RecipeTag back
    queried_recipe_tag = test_session.get(RecipeTag, recipe_tag.id)
    
    # Verify the query worked
    assert queried_recipe_tag is not None
    assert queried_recipe_tag.id == recipe_tag.id
    assert queried_recipe_tag.recipe_id == recipe.id
    assert queried_recipe_tag.tag_id == tag.id

def test_recipe_tag_database_constraints(test_session):
    """Test that RecipeTag database constraints work correctly."""
    # Create test data
    user = User(
        email="test@example.com",
        full_name="Test User",
        hashed_password="hashed_password"
    )
    test_session.add(user)
    test_session.commit()
    test_session.refresh(user)
    
    recipe = Recipe(
        title="Test Recipe",
        description="A test recipe",
        ingredients=[{"name": "flour", "amount": "2 cups"}],
        instructions=["Mix ingredients"],
        preparation_time=10,
        cooking_time=20,
        servings=4,
        user_id=user.uuid
    )
    test_session.add(recipe)
    test_session.commit()
    test_session.refresh(recipe)
    
    tag = Tag(
        name="test tag",
        category=TagCategory.MEAL_TYPES
    )
    test_session.add(tag)
    test_session.commit()
    test_session.refresh(tag)
    
    # Create a RecipeTag
    recipe_tag = RecipeTag(
        recipe_id=recipe.id,
        tag_id=tag.id
    )
    test_session.add(recipe_tag)
    test_session.commit()
    test_session.refresh(recipe_tag)
    
    # Try to create another RecipeTag with the same recipe_id and tag_id
    # This should work (no unique constraint on the combination in SQLite)
    # But in PostgreSQL with composite primary key, this would fail
    duplicate_recipe_tag = RecipeTag(
        recipe_id=recipe.id,
        tag_id=tag.id
    )
    test_session.add(duplicate_recipe_tag)
    
    # This should work in SQLite but would fail in PostgreSQL
    # We'll test that it at least doesn't crash
    try:
        test_session.commit()
        test_session.refresh(duplicate_recipe_tag)
        # If we get here, it worked (SQLite behavior)
        assert duplicate_recipe_tag.id != recipe_tag.id
    except Exception as e:
        # If we get an exception, it's probably a constraint violation (PostgreSQL behavior)
        assert "unique" in str(e).lower() or "duplicate" in str(e).lower()

def test_recipe_tag_database_foreign_key_constraints(test_session):
    """Test that RecipeTag foreign key constraints work correctly."""
    # Try to create a RecipeTag with non-existent recipe_id and tag_id
    recipe_tag = RecipeTag(
        recipe_id=99999,  # Non-existent recipe ID
        tag_id=99999      # Non-existent tag ID
    )
    test_session.add(recipe_tag)
    
    # SQLite doesn't enforce foreign key constraints by default
    # So this will succeed, but we can test that the data is stored correctly
    test_session.commit()
    test_session.refresh(recipe_tag)
    
    # Verify that the RecipeTag was created with the non-existent IDs
    assert recipe_tag.recipe_id == 99999
    assert recipe_tag.tag_id == 99999
    assert recipe_tag.id is not None
    
    # Note: In a real PostgreSQL database with foreign key constraints enabled,
    # this would fail with a foreign key constraint violation
