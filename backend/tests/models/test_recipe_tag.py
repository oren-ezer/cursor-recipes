import pytest
from src.models.recipe_tag import RecipeTag

def test_create_recipe_tag_instance():
    """Test creating a RecipeTag instance with all fields."""
    recipe_tag_data = {
        "recipe_id": 1,
        "tag_id": 2
    }
    recipe_tag = RecipeTag(**recipe_tag_data)

    assert recipe_tag.recipe_id == recipe_tag_data["recipe_id"]
    assert recipe_tag.tag_id == recipe_tag_data["tag_id"]
    assert recipe_tag.id is None  # Assuming id is generated by the DB or BaseModel

def test_recipe_tag_string_representation():
    """Test the string representation of the RecipeTag model."""
    recipe_tag_data = {
        "recipe_id": 1,
        "tag_id": 2
    }
    recipe_tag = RecipeTag(**recipe_tag_data)
    
    expected_repr = f"<RecipeTag recipe_id={recipe_tag.recipe_id} tag_id={recipe_tag.tag_id}>"
    assert str(recipe_tag) == f"<RecipeTag recipe_id={recipe_tag.recipe_id} tag_id={recipe_tag.tag_id}>"
    assert repr(recipe_tag) == expected_repr

def test_recipe_tag_comparison():
    """Test recipe tag comparison functionality."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag2 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag3 = RecipeTag(recipe_id=1, tag_id=3)
    recipe_tag4 = RecipeTag(recipe_id=2, tag_id=2)
    
    # Test equality
    assert recipe_tag1 == recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag1 != recipe_tag4
    
    # Test that different instances with same values are equal
    assert recipe_tag1 == recipe_tag2  # Should be equal despite being different instances

def test_recipe_tag_with_different_recipe_ids():
    """Test recipe tags with different recipe IDs."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=1)
    recipe_tag2 = RecipeTag(recipe_id=2, tag_id=1)
    recipe_tag3 = RecipeTag(recipe_id=3, tag_id=1)
    
    # All should be different
    assert recipe_tag1 != recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag2 != recipe_tag3
    
    # But they should have the same tag_id
    assert recipe_tag1.tag_id == recipe_tag2.tag_id == recipe_tag3.tag_id

def test_recipe_tag_with_different_tag_ids():
    """Test recipe tags with different tag IDs."""
    recipe_tag1 = RecipeTag(recipe_id=1, tag_id=1)
    recipe_tag2 = RecipeTag(recipe_id=1, tag_id=2)
    recipe_tag3 = RecipeTag(recipe_id=1, tag_id=3)
    
    # All should be different
    assert recipe_tag1 != recipe_tag2
    assert recipe_tag1 != recipe_tag3
    assert recipe_tag2 != recipe_tag3
    
    # But they should have the same recipe_id
    assert recipe_tag1.recipe_id == recipe_tag2.recipe_id == recipe_tag3.recipe_id

def test_recipe_tag_edge_cases():
    """Test edge cases for recipe tag creation."""
    # Test with zero IDs (though these might not be valid in practice)
    recipe_tag = RecipeTag(recipe_id=0, tag_id=0)
    assert recipe_tag.recipe_id == 0
    assert recipe_tag.tag_id == 0
    
    # Test with large IDs
    recipe_tag = RecipeTag(recipe_id=999999, tag_id=999999)
    assert recipe_tag.recipe_id == 999999
    assert recipe_tag.tag_id == 999999

def test_recipe_tag_immutability():
    """Test that recipe tag fields are properly set and immutable."""
    recipe_tag = RecipeTag(recipe_id=1, tag_id=2)
    
    # Test initial values
    assert recipe_tag.recipe_id == 1
    assert recipe_tag.tag_id == 2
    
    # Test that we can't accidentally change the values
    # (This would be caught by Pydantic validation if we tried to reassign)

def test_recipe_tag_relationship_simulation():
    """Test that recipe tags properly represent many-to-many relationships."""
    # Simulate a recipe with multiple tags
    recipe_id = 1
    tag_ids = [1, 2, 3, 4, 5]
    
    recipe_tags = [RecipeTag(recipe_id=recipe_id, tag_id=tag_id) for tag_id in tag_ids]
    
    # All should have the same recipe_id
    for recipe_tag in recipe_tags:
        assert recipe_tag.recipe_id == recipe_id
    
    # All should have different tag_ids
    tag_id_set = {rt.tag_id for rt in recipe_tags}
    assert len(tag_id_set) == len(tag_ids)
    
    # All should be unique (check manually since RecipeTag is not hashable)
    for i, rt1 in enumerate(recipe_tags):
        for j, rt2 in enumerate(recipe_tags):
            if i != j:
                assert rt1 != rt2

def test_recipe_tag_composite_key_simulation():
    """Test that recipe tags behave like they have a composite primary key."""
    # Create multiple recipe tags with different combinations
    recipe_tags = [
        RecipeTag(recipe_id=1, tag_id=1),
        RecipeTag(recipe_id=1, tag_id=2),
        RecipeTag(recipe_id=2, tag_id=1),
        RecipeTag(recipe_id=2, tag_id=2),
    ]
    
    # All should be unique (check manually since RecipeTag is not hashable)
    for i, rt1 in enumerate(recipe_tags):
        for j, rt2 in enumerate(recipe_tags):
            if i != j:
                assert rt1 != rt2
    
    # Test that same combination is equal
    rt1 = RecipeTag(recipe_id=1, tag_id=1)
    rt2 = RecipeTag(recipe_id=1, tag_id=1)
    assert rt1 == rt2

def test_recipe_tag_validation():
    """Test that recipe tag validation works correctly."""
    # Test with valid integer IDs
    recipe_tag = RecipeTag(recipe_id=1, tag_id=2)
    assert recipe_tag.recipe_id == 1
    assert recipe_tag.tag_id == 2
    
    # Test with string IDs (should be converted to int if possible)
    # This depends on how SQLModel handles the conversion
    # For now, we'll test with integers as that's what the model expects

def test_recipe_tag_representation_consistency():
    """Test that string representations are consistent."""
    recipe_tag = RecipeTag(recipe_id=123, tag_id=456)
    
    # Test str representation
    str_repr = str(recipe_tag)
    assert "RecipeTag" in str_repr
    assert "123" in str_repr
    assert "456" in str_repr
    
    # Test repr representation
    repr_repr = repr(recipe_tag)
    assert "RecipeTag" in repr_repr
    assert "123" in repr_repr
    assert "456" in repr_repr
    
    # Both should be the same for this model
    assert str_repr == repr_repr

def test_recipe_tag_equality_consistency():
    """Test that recipe tag equality is consistent."""
    rt1 = RecipeTag(recipe_id=1, tag_id=2)
    rt2 = RecipeTag(recipe_id=1, tag_id=2)
    rt3 = RecipeTag(recipe_id=1, tag_id=3)
    
    # Equal objects should be equal
    assert rt1 == rt2
    assert rt2 == rt1  # Symmetric
    
    # Different objects should not be equal
    assert rt1 != rt3
    assert rt3 != rt1  # Symmetric
    
    # Reflexive
    assert rt1 == rt1
    assert rt2 == rt2
    assert rt3 == rt3

def test_recipe_tag_not_hashable():
    """Test that recipe tags are not hashable (as expected for mutable objects)."""
    rt1 = RecipeTag(recipe_id=1, tag_id=2)
    
    # RecipeTag should not be hashable
    with pytest.raises(TypeError, match="unhashable type"):
        hash(rt1)
    
    # Should not be usable in sets
    with pytest.raises(TypeError, match="unhashable type"):
        {rt1}
    
    # Should not be usable as dictionary keys
    with pytest.raises(TypeError, match="unhashable type"):
        {rt1: "value"}
