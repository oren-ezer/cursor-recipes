import pytest
from src.models.tag import Tag
from pydantic import ValidationError

def test_create_tag_instance():
    """Test creating a Tag instance with all fields."""
    tag_data = {
        "name": "Breakfast"
    }
    tag = Tag(**tag_data)

    assert tag.name == tag_data["name"].lower().strip()
    assert tag.id is None  # Assuming id is generated by the DB or BaseModel
    assert tag.uuid is not None

def test_tag_uuid_generation():
    """Test that UUID is automatically generated for new tags."""
    tag_data = {
        "name": "Dinner"
    }
    tag = Tag(**tag_data)
    
    assert tag.uuid is not None
    assert isinstance(tag.uuid, str)
    assert len(tag.uuid) > 0

def test_tag_string_representation():
    """Test the string representation of the Tag model."""
    tag_data = {
        "name": "Dessert"
    }
    tag = Tag(**tag_data)
    
    expected_repr = f"<Tag name={tag.name} id={tag.id} recipe_counter={tag.recipe_counter} category={tag.category}>"
    assert str(tag) == f"<Tag name={tag.name}>"
    assert repr(tag) == expected_repr

def test_tag_name_validation_rules():
    """Test all tag name validation rules."""
    # Test empty name
    with pytest.raises(ValidationError, match="Tag name cannot be empty"):
        Tag(name="")

    # Test name too short
    with pytest.raises(ValidationError, match="Tag name must be at least 2 characters long"):
        Tag(name="a")

    # Test name too long
    with pytest.raises(ValidationError, match="Tag name cannot exceed 50 characters"):
        Tag(name="a" * 51)

    # Test invalid characters
    with pytest.raises(ValidationError, match="Tag name can only contain letters, numbers, spaces, hyphens, and underscores"):
        Tag(name="invalid@tag")

    # Test valid names
    valid_names = [
        "Breakfast",
        "dinner",
        "Dessert",
        "quick-meal",
        "slow_cooker",
        "vegetarian dish",
        "gluten-free",
        "keto_friendly",
        "low carb meal",
        "high protein"
    ]
    
    for name in valid_names:
        tag = Tag(name=name)
        # Name should be normalized (lowercase and trimmed)
        assert tag.name == name.lower().strip()

def test_tag_name_normalization():
    """Test that tag names are properly normalized."""
    # Test whitespace trimming
    tag1 = Tag(name="  Breakfast  ")
    assert tag1.name == "breakfast"

    # Test case conversion
    tag2 = Tag(name="DINNER")
    assert tag2.name == "dinner"

    # Test mixed case and whitespace
    tag3 = Tag(name="  Quick Meal  ")
    assert tag3.name == "quick meal"

def test_tag_comparison():
    """Test tag comparison functionality."""
    tag1 = Tag(name="same")
    tag2 = Tag(name="same")
    tag3 = Tag(name="different")
    
    # Test equality (case-insensitive)
    assert tag1 == tag2
    assert tag1 != tag3
    
    # Test that different UUIDs don't affect equality
    assert tag1.uuid != tag2.uuid
    assert tag1 == tag2  # Should still be equal despite different UUIDs

    # Test case-insensitive comparison
    tag4 = Tag(name="SAME")
    assert tag1 == tag4

def test_tag_normalize_name_method():
    """Test the normalize_name class method."""
    # Test basic normalization
    assert Tag.normalize_name("  Breakfast  ") == "breakfast"
    assert Tag.normalize_name("DINNER") == "dinner"
    assert Tag.normalize_name("Quick-Meal") == "quick-meal"
    assert Tag.normalize_name("slow_cooker") == "slow_cooker"

    # Test edge cases
    assert Tag.normalize_name("") == ""
    assert Tag.normalize_name("   ") == ""
    assert Tag.normalize_name("A") == "a"

def test_tag_with_special_characters():
    """Test tags with valid special characters."""
    valid_special_chars = [
        "quick-meal",
        "slow_cooker", 
        "vegetarian dish",
        "gluten-free",
        "keto_friendly",
        "low-carb",
        "high_protein"
    ]
    
    for name in valid_special_chars:
        tag = Tag(name=name)
        assert tag.name == name.lower().strip()

def test_tag_edge_cases():
    """Test edge cases for tag creation."""
    # Test minimum valid length
    tag = Tag(name="ab")
    assert tag.name == "ab"
    
    # Test maximum valid length
    tag = Tag(name="a" * 50)
    assert tag.name == "a" * 50
    
    # Test with numbers
    tag = Tag(name="recipe123")
    assert tag.name == "recipe123"
    
    # Test with spaces
    tag = Tag(name="quick meal")
    assert tag.name == "quick meal"

def test_tag_validation_error_messages():
    """Test that validation errors provide clear messages."""
    # Test non-string input
    with pytest.raises(ValidationError, match="Input should be a valid string"):
        Tag(name=123)

    # Test empty string
    with pytest.raises(ValidationError, match="Tag name cannot be empty"):
        Tag(name="")

    # Test whitespace-only string
    with pytest.raises(ValidationError, match="Tag name must be at least 2 characters long"):
        Tag(name="   ")

    # Test too short
    with pytest.raises(ValidationError, match="Tag name must be at least 2 characters long"):
        Tag(name="a")

    # Test too long
    with pytest.raises(ValidationError, match="Tag name cannot exceed 50 characters"):
        Tag(name="a" * 51)

    # Test invalid characters
    with pytest.raises(ValidationError, match="Tag name can only contain letters, numbers, spaces, hyphens, and underscores"):
        Tag(name="invalid@tag")

def test_tag_unique_constraint_simulation():
    """Test that tags with same normalized name are considered equal."""
    tag1 = Tag(name="Breakfast")
    tag2 = Tag(name="breakfast")
    tag3 = Tag(name="  BREAKFAST  ")
    
    # All should be considered equal due to normalization
    assert tag1 == tag2
    assert tag1 == tag3
    assert tag2 == tag3
    
    # But they should have different UUIDs
    assert tag1.uuid != tag2.uuid
    assert tag1.uuid != tag3.uuid
    assert tag2.uuid != tag3.uuid
